#pragma once
#include <stdint.h>
#include <stddef.h>

// 16-bit LFSR (kept for compatibility)
class LFSR16 {
public:
  LFSR16(uint16_t seed, uint16_t tapMask)
    : state_(seed ? seed : 1), taps_(tapMask ? tapMask : 0x0029) {}
  void reseed(uint16_t seed) { state_ = seed ? seed : 1; }
  uint8_t stepBit() {
    uint8_t out = (uint8_t)(state_ & 1u);
    // Compute parity of tapped bits
    uint16_t x = state_ & taps_;
    x ^= x >> 8;
    x ^= x >> 4;
    x ^= x >> 2;
    x ^= x >> 1;
    uint8_t fb = x & 1;
    state_ = (uint16_t)((state_ >> 1) | (uint16_t)(fb << 15));
    return out;
  }
  uint8_t nextByte() { uint8_t b = 0; for (int i = 0; i < 8; ++i) b |= (stepBit() << i); return b; }
  void generate(uint8_t* out, size_t n) { for (size_t i = 0; i < n; ++i) out[i] = nextByte(); }
  void xorBuffer(uint8_t* buf, size_t n) { for (size_t i = 0; i < n; ++i) buf[i] ^= nextByte(); }

private:
  uint16_t state_;
  uint16_t taps_;
};

/**
 * @brief 32-bit Linear Feedback Shift Register (LFSR) PRNG
 * 
 * Generates pseudo-random bytes using a configurable feedback polynomial.
 * Default taps mask (0xA3000001) is chosen for good randomness properties.
 */
class LFSR32 {
public:
    /**
     * @brief Construct a new LFSR32 object
     * 
     * @param seed     Initial state (must not be 0; if 0, defaults to 0xACE1)
     * @param tapMask  Feedback polynomial bitmask (default: 0xA3000001)
     */
    LFSR32(uint32_t seed, uint32_t tapMask = 0xA3000001u)
        : state_(seed ? seed : 0xACE1u), taps_(tapMask ? tapMask : 0xA3000001u) {}

    /**
     * @brief Reseed the LFSR
     * 
     * @param seed     New seed value
     * @param tapMask  New tap mask (optional)
     */
    void reseed(uint32_t seed, uint32_t tapMask = 0) {
        state_ = seed ? seed : 0xACE1u;
        if (tapMask) taps_ = tapMask;
    }

    /**
     * @brief Generate next bit from the LFSR
     * @return uint8_t The generated bit (0 or 1)
     */
    uint8_t stepBit() {
        uint8_t out = (uint8_t)(state_ & 1u);
#if defined(__GNUC__)
        uint8_t fb = __builtin_parity(state_ & taps_);
#else
        // Fallback parity
        uint32_t v = state_ & taps_;
        v ^= v >> 16; v ^= v >> 8; v ^= v >> 4; v ^= v >> 2; v ^= v >> 1;
        uint8_t fb = (uint8_t)(v & 1u);
#endif
        state_ = (state_ >> 1) | ((uint32_t)fb << 31);
        return out;
    }

    /**
     * @brief Generate next pseudo-random byte
     * @return uint8_t The generated byte
     */
    uint8_t nextByte() {
        uint8_t b = 0;
        for (int i = 0; i < 8; ++i) {
            b |= (stepBit() << i);
        }
        return b;
    }

    /**
     * @brief Fill a buffer with pseudo-random bytes
     * 
     * @param out Pointer to output buffer
     * @param n   Number of bytes to generate
     */
    void generate(uint8_t *out, size_t n) {
        for (size_t i = 0; i < n; ++i) {
            out[i] = nextByte();
        }
    }

    /**
     * @brief XOR a buffer with pseudo-random bytes
     * 
     * @param buf Pointer to buffer
     * @param n   Number of bytes to XOR
     */
    void xorBuffer(uint8_t *buf, size_t n) {
        for (size_t i = 0; i < n; ++i) {
            buf[i] ^= nextByte();
        }
    }

private:
    uint32_t state_;
    uint32_t taps_;
};
