import matplotlib.pyplot as plt
import matplotlib.animation as animation
import numpy as np

# Simplified Python version of Tinkerbell from C++ code for visualization
class Tinkerbell:
    def __init__(self, chaosKey):
        self.a = self.map_range16(self.u16(chaosKey[0], chaosKey[1]), -1.2, -0.3)
        self.b = self.map_range16(self.u16(chaosKey[2], chaosKey[3]), -1.0, -0.2)
        self.c = self.map_range16(self.u16(chaosKey[4], chaosKey[5]), 1.5, 2.5)
        self.d = self.map_range16(self.u16(chaosKey[6], chaosKey[7]), 0.3, 1.3)

        self.x = self.frac_from16(chaosKey[8], chaosKey[9])
        self.y = self.frac_from16(chaosKey[10], chaosKey[11])

        ctrl = chaosKey[12]
        self.alpha = self.map_byte(chaosKey[13], -2, 2)
        self.beta = self.map_byte(chaosKey[14], -2, 2)
        self.gamma = self.map_byte(ctrl ^ chaosKey[13], -4, 4)
        self.delta = self.map_byte((~ctrl & 0xFF) ^ chaosKey[14], -4, 4)
        self.eps = self.map_byte(chaosKey[15], -4, 4)
        self.zeta = self.map_byte((ctrl + chaosKey[15]) & 0xFF, -8, 8)
        self.eta = self.map_byte((ctrl ^ (chaosKey[15] >> 1)) & 0xFF, -8, 8)

        self.s = (chaosKey[0] << 24) | (chaosKey[1] << 16) | (chaosKey[2] << 8) | chaosKey[3]
        if self.s == 0:
            self.s = 0x9E3779B9
        self.inc = 0x6a09e667 ^ ((chaosKey[4] << 16) | chaosKey[5])
        self.rot1 = 1 + (chaosKey[6] & 31)
        self.rot2 = 1 + (chaosKey[7] & 31)

        # Burn-in
        for _ in range(128):
            self.next_byte()

    def u16(self, hi, lo):
        return (hi << 8) | lo

    def map_range16(self, v, lo, hi):
        t = v / 65535.0
        return lo + t * (hi - lo)

    def frac_from16(self, hi, lo):
        u = (hi << 8) | lo
        f = (u + 1.0) / 65536.0
        return min(f, 0.999984741)

    def map_byte(self, b, lo, hi):
        return lo + (b / 255.0) * (hi - lo)

    def rotl32(self, x, r):
        return ((x << r) & 0xFFFFFFFF) | (x >> (32 - r))

    def xorshift32_mix(self):
        self.s = (self.s + self.inc) & 0xFFFFFFFF
        z = (self.s + 0x9e3779b9) & 0xFFFFFFFF
        z ^= (z >> 30)
        z = (z * 0xbf58476d) & 0xFFFFFFFF
        z ^= (z >> 27)
        z = (z * 0x94d049bb) & 0xFFFFFFFF
        z ^= (z >> 31)
        return z & 0xFFFFFFFF

    def polyP(self):
        x, y = self.x, self.y
        xx, yy = x*x, y*y
        xxx, yyy = xx*x, yy*y
        return (self.alpha*x + self.beta*y +
                self.gamma*xx + self.delta*yy +
                self.eps*(x*y) +
                self.zeta*xxx + self.eta*yyy)

    def next_bit(self):
        xn, yn = self.x, self.y
        x1 = xn*xn - yn*yn + self.a * xn + self.b * yn
        y1 = 2*xn*yn + self.c * xn + self.d * yn
        self.x, self.y = x1, y1

        pp = self.polyP()

        ux = int(abs(x1) * 0xFFFFFFFF) & 0xFFFFFFFF
        uy = int(abs(y1) * 0xFFFFFFFF) & 0xFFFFFFFF
        up = int(abs(pp) * 0xFFFFFFFF) & 0xFFFFFFFF

        xs = self.xorshift32_mix()
        mix = ux ^ self.rotl32(uy, self.rot1) ^ self.rotl32(up, self.rot2) ^ xs
        mix = (mix * 0xA3B1C2D3) & 0xFFFFFFFF
        mix ^= (mix >> 16)
        return mix & 1

    def next_byte(self):
        b = 0
        for i in range(8):
            b |= (self.next_bit() << i)
        return b

# Prepare animation data
chaosKey = bytes(range(16))  # Example key
tb = Tinkerbell(chaosKey)
num_bytes = 8

# Capture chaotic states and byte outputs
xy_states = []
byte_outputs = []
for _ in range(num_bytes):
    xy_states.append((tb.x, tb.y))
    byte_outputs.append(tb.next_byte())

# Animation setup
fig, axes = plt.subplots(1, 2, figsize=(8, 4))
ax_xy, ax_bytes = axes

# Left: chaotic trajectory
ax_xy.set_title("Tinkerbell (x, y) states")
ax_xy.set_xlim(-2, 2)
ax_xy.set_ylim(-2, 2)
point, = ax_xy.plot([], [], 'ro')

# Right: byte outputs
ax_bytes.set_title("Generated Byte Values")
ax_bytes.set_xlim(-0.5, num_bytes - 0.5)
ax_bytes.set_ylim(0, 260)
bar_rects = ax_bytes.bar(range(num_bytes), [0]*num_bytes, color='tab:green')

def init():
    point.set_data([], [])
    for rect in bar_rects:
        rect.set_height(0)
    return [point, *bar_rects]

def update(frame):
    # Update chaotic map point
    x, y = xy_states[frame]
    point.set_data([x], [y])

    # Update bar chart
    for i, rect in enumerate(bar_rects):
        if i <= frame:
            rect.set_height(byte_outputs[i])
    return [point, *bar_rects]

ani = animation.FuncAnimation(fig, update, frames=num_bytes, init_func=init,
                               blit=True, interval=800, repeat=False)

plt.show()
